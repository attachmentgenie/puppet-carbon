[cache:<%= @cache_name %>]
CONF_DIR                           = <%= scope.lookupvar('carbon::gr_config_dir') %>
<% if scope.lookupvar('carbon::cc_local_data_dir') -%>
LOCAL_DATA_DIR                     = <%= scope.lookupvar('carbon::cc_local_data_dir') %>
<% end -%>
LOG_DIR                            = <%= scope.lookupvar('carbon::cc_log_dir') %>
PID_DIR                            = <%= scope.lookupvar('carbon::cc_pid_dir') %>
STORAGE_DIR                        = <%= scope.lookupvar('carbon::cc_storage_dir') %>
WHITELISTS_DIR                     = <%= scope.lookupvar('carbon::cc_whitelists_dir') %>

# Specify the user to drop privileges to
# If this is blank carbon runs as the user that invokes it
# This user must have write access to the local data directory
USER                               = <%= scope.lookupvar('carbon::gr_user') %>

#
# NOTE: The above settings must be set under [relay] and [aggregator]
#       to take effect for those daemons as well

# Limit the size of the cache to avoid swapping or becoming CPU bound.
# Sorts and serving cache queries gets more expensive as the cache grows.
# Use the value "inf" (infinity) for an unlimited cache size.
MAX_CACHE_SIZE                     = <%= scope.lookupvar('carbon::cc_max_cache_size') %>

# Limits the number of whisper update_many() calls per second, which effectively
# means the number of write requests sent to the disk. This is intended to
# prevent over-utilizing the disk and thus starving the rest of the system.
# When the rate of required updates exceeds this, then carbon's caching will
# take effect and increase the overall throughput accordingly.
MAX_UPDATES_PER_SECOND             = <%= scope.lookupvar('carbon::cc_max_updates_per_second') %>

# Softly limits the number of whisper files that get created each minute.
# Setting this value low (e.g. 50) is a good way to ensure that your carbon
# system will not be adversely impacted when a bunch of new metrics are
# sent to it. The trade off is that any metrics received in excess of this
# value will be silently dropped, and the whisper file will not be created
# until such point as a subsequent metric is received and fits within the
# defined rate limit. Setting this value high (like "inf" for infinity) will
# cause carbon to create the files quickly but at the risk of increased I/O.
MAX_CREATES_PER_MINUTE             = <%= scope.lookupvar('carbon::cc_max_creates_per_minute') %>

# Enable daily log rotation. If disabled, carbon will automatically re-open
# the file if it's rotated out of place (e.g. by logrotate daemon)
ENABLE_LOGROTATION                 = <%= scope.lookupvar('carbon::cc_enable_logrotation') %>


# Set this to False to drop datapoints received after the cache
# reaches MAX_CACHE_SIZE. If this is True (the default) then sockets
# over which metrics are received will temporarily stop accepting
# data until the cache size falls below 95% MAX_CACHE_SIZE.
USE_FLOW_CONTROL                   = <%= scope.lookupvar('carbon::cc_use_flow_control') %>

# By default, carbon-cache will log every whisper update and cache hit. This can be excessive and
# degrade performance if logging on the same volume as the whisper data is stored.
LOG_UPDATES                        = <%= scope.lookupvar('carbon::cc_log_updates') %>
LOG_CACHE_HITS                     = <%= scope.lookupvar('carbon::cc_log_cache_hits') %>
LOG_CACHE_QUEUE_SORTS              = <%= scope.lookupvar('carbon::cc_log_cache_queue_sorts') %>

# The thread that writes metrics to disk can use on of the following strategies
# determining the order in which metrics are removed from cache and flushed to
# disk. The default option preserves the same behavior as has been historically
# available in version 0.9.10.
#
# sorted - All metrics in the cache will be counted and an ordered list of
# them will be sorted according to the number of datapoints in the cache at the
# moment of the list's creation. Metrics will then be flushed from the cache to
# disk in that order.
#
# max - The writer thread will always pop and flush the metric from cache
# that has the most datapoints. This will give a strong flush preference to
# frequently updated metrics and will also reduce random file-io. Infrequently
# updated metrics may only ever be persisted to disk at daemon shutdown if
# there are a large number of metrics which receive very frequent updates OR if
# disk i/o is very slow.
#
# naive - Metrics will be flushed from the cache to disk in an unordered
# fashion. This strategy may be desirable in situations where the storage for
# whisper files is solid state, CPU resources are very limited or deference to
# the OS's i/o scheduler is expected to compensate for the random write
# pattern.
#
CACHE_WRITE_STRATEGY               = <%= scope.lookupvar('carbon::cc_cache_write_strategy') %>

# On some systems it is desirable for whisper to write synchronously.
# Set this option to True if you'd like to try this. Basically it will
# shift the onus of buffering writes from the kernel into carbon's cache.
WHISPER_AUTOFLUSH                  = <%= scope.lookupvar('carbon::cc_whisper_autoflush') %>

# By default new Whisper files are created pre-allocated with the data region
# filled with zeros to prevent fragmentation and speed up contiguous reads and
# writes (which are common). Enabling this option will cause Whisper to create
# the file sparsely instead. Enabling this option may allow a large increase of
# MAX_CREATES_PER_MINUTE but may have longer term performance implications
# depending on the underlying storage configuration.
<% unless [:undef, nil].include? scope['carbon::cc_whisper_sparse_create'] -%>
WHISPER_SPARSE_CREATE              = <%= scope['carbon::cc_whisper_sparse_create'] %>
<% end -%>

# Only beneficial on linux filesystems that support the fallocate system call.
# It maintains the benefits of contiguous reads/writes, but with a potentially
# much faster creation speed, by allowing the kernel to handle the block
# allocation and zero-ing. Enabling this option may allow a large increase of
# MAX_CREATES_PER_MINUTE. If enabled on an OS or filesystem that is unsupported
# this option will gracefully fallback to standard POSIX file access methods.
WHISPER_FALLOCATE_CREATE           = <%= scope.lookupvar('carbon::cc_whisper_fallocate_create') %>

# Enabling this option will cause Whisper to lock each Whisper file it writes
# to with an exclusive lock (LOCK_EX, see: man 2 flock). This is useful when
# multiple carbon-cache daemons are writing to the same files
# WHISPER_LOCK_WRITES = False
<% unless [:undef, nil].include? scope['carbon::cc_whisper_lock_writes'] -%>
WHISPER_LOCK_WRITES                = <%= scope['carbon::cc_whisper_lock_writes'] %>
<% end -%>

# Set this to True to enable whitelisting and blacklisting of metrics in
# CONF_DIR/whitelist and CONF_DIR/blacklist. If the whitelist is missing or
# empty, all metrics will pass through
<% unless [:undef, nil].include? scope['carbon::cc_use_whitelist'] -%>
USE_WHITELIST                      = <%= scope['carbon::cc_use_whitelist'] %>
<% end -%>

# Set to false to disable logging of successful connections
LOG_LISTENER_CONNECTIONS           = <%= scope.lookupvar('carbon::cc_log_listener_connections') %>

# Per security concerns outlined in Bug #817247 the pickle receiver
# will use a more secure and slightly less efficient unpickler.
# Set this to True to revert to the old-fashioned insecure unpickler.
USE_INSECURE_UNPICKLER             = <%= scope.lookupvar('carbon::cc_use_insecure_unpickler') %>

# Set the interface and port for the line (plain text) listener.  Setting the
# interface to 0.0.0.0 listens on all interfaces.  Port can be set to 0 to
# disable this listener if it is not required.
LINE_RECEIVER_INTERFACE            = <%= @line_receiver_interface %>
LINE_RECEIVER_PORT                 = <%= @line_receiver_port %>

# Set this to True to enable the UDP listener. By default this is off
# because it is very common to run multiple carbon daemons and managing
# another (rarely used) port for every carbon instance is not fun.
ENABLE_UDP_LISTENER                = <%= scope.lookupvar('carbon::cc_enable_udp_listener') %>
UDP_RECEIVER_INTERFACE             = <%= @udp_receiver_interface %>
UDP_RECEIVER_PORT                  = <%= @udp_receiver_port %>

# Set the interface and port for the pickle listener.  Setting the interface to
# 0.0.0.0 listens on all interfaces.  Port can be set to 0 to disable this
# listener if it is not required.
PICKLE_RECEIVER_INTERFACE          = <%= @pickle_receiver_interface %>
PICKLE_RECEIVER_PORT               = <%= @pickle_receiver_port %>

# Set the TCP backlog for the listen socket created by the pickle receiver. You
# shouldn't change this unless you know what you're doing.
# PICKLE_RECEIVER_BACKLOG = 1024
<% unless [:undef, nil].include? scope['carbon::cc_pickle_receiver_backlog'] -%>
PICKLE_RECEIVER_BACKLOG            = <%= scope['carbon::cc_pickle_receiver_backlog'] %>
<% end -%>

CACHE_QUERY_INTERFACE              = <%= scope.lookupvar('carbon::cc_cache_query_interface') %>
CACHE_QUERY_PORT                   = <%= scope.lookupvar('carbon::cc_cache_query_port') %>

# If defined, this changes the MAX_UPDATES_PER_SECOND in Carbon when a
# stop/shutdown is initiated.  This helps when MAX_UPDATES_PER_SECOND is
# relatively low and carbon has cached a lot of updates; it enables the carbon
# daemon to shutdown more quickly.
# MAX_UPDATES_PER_SECOND_ON_SHUTDOWN = 1000
<% unless [:undef, nil].include? scope['carbon::cc_max_updates_per_second_on_shutdown'] -%>
MAX_UPDATES_PER_SECOND_ON_SHUTDOWN = <%= scope['carbon::cc_max_updates_per_second_on_shutdown'] %>
<% end -%>

# Set the TCP backlog for the listen socket created by the line receiver. You
# shouldn't change this unless you know what you're doing.
# LINE_RECEIVER_BACKLOG = 1024
<% unless [:undef, nil].include? scope['carbon::cc_line_receiver_backlog'] -%>
LINE_RECEIVER_BACKLOG              = <%= scope['carbon::cc_line_receiver_backlog'] %>
<% end -%>

# Set the TCP backlog for the listen socket created by the cache query
# listener. You shouldn't change this unless you know what you're doing.
# CACHE_QUERY_BACKLOG = 1024
<% unless [:undef, nil].include? scope['carbon::cc_cache_query_backlog'] -%>
CACHE_QUERY_BACKLOG                = <%= scope['carbon::cc_cache_query_backlog'] %>
<% end -%>

















# By default, carbon itself will log statistics (such as a count,
# metricsReceived) with the top level prefix of 'carbon' at an interval of 60
# seconds. Set CARBON_METRIC_INTERVAL to 0 to disable instrumentation
CARBON_METRIC_PREFIX = <%= scope.lookupvar('carbon::cc_carbon_metric_prefix') %>
CARBON_METRIC_INTERVAL = <%= scope.lookupvar('carbon::cc_carbon_metric_interval') %>

# Enable AMQP if you want to receve metrics using an amqp broker
ENABLE_AMQP = <%= scope.lookupvar('carbon::cc_enable_amqp') %>

<% if scope.lookupvar('carbon::cc_enable_amqp') == "True" -%>
# Verbose means a line will be logged for every metric received
# useful for testing
AMQP_VERBOSE = <%= scope.lookupvar('carbon::cc_amqp_verbose') %>

AMQP_HOST = <%= scope.lookupvar('carbon::cc_amqp_host') %>
AMQP_PORT = <%= scope.lookupvar('carbon::cc_amqp_port') %>
AMQP_VHOST = <%= scope.lookupvar('carbon::cc_amqp_vhost') %>
AMQP_USER = <%= scope.lookupvar('carbon::cc_amqp_user') %>
AMQP_PASSWORD = <%= scope.lookupvar('carbon::cc_amqp_password') %>
AMQP_EXCHANGE = <%= scope.lookupvar('carbon::cc_amqp_exchange') %>
AMQP_METRIC_NAME_IN_BODY = <%= scope.lookupvar('carbon::cc_amqp_metric_name_in_body') %>
<% end -%>

# The manhole interface allows you to SSH into the carbon daemon
# and get a python interpreter. BE CAREFUL WITH THIS! If you do
# something like time.sleep() in the interpreter, the whole process
# will sleep! This is *extremely* helpful in debugging, assuming
# you are familiar with the code. If you are not, please don't
# mess with this, you are asking for trouble :)
#
# ENABLE_MANHOLE = False
# MANHOLE_INTERFACE = 127.0.0.1
# MANHOLE_PORT = 7222
# MANHOLE_USER = admin
# MANHOLE_PUBLIC_KEY = ssh-rsa AAAAB3NzaC1yc2EAAAABiwAaAIEAoxN0sv/e4eZCPpi3N3KYvyzRaBaMeS2RsOQ/cDuKv11dlNzVeiyc3RFmCv5Rjwn/lQ79y0zyHxw67qLyhQ/kDzINc4cY41ivuQXm2tPmgvexdrBv5nsfEpjs3gLZfJnyvlcVyWK/lId8WUvEWSWHTzsbtmXAF2raJMdgLTbQ8wE=

# Patterns for all of the metrics this machine will store. Read more at
# http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol#Bindings
#
# Example: store all sales, linux servers, and utilization metrics
# BIND_PATTERNS = sales.#, servers.linux.#, #.utilization
#
# Example: store everything
# BIND_PATTERNS = #
